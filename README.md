## QA сервис
Проект реализован из нескольких приложений, связанных между собой внутренней сеткой и балансировщиком docker swarm

Загрузка данных, необходимых для поднятия служб, на ноды и запуск самих служб осуществляется c помощью ansible playbooks.

По-умолчанию, считается, что swarm инициализирован, создана сеть, все ноды отмечены соответствующими node.labels TAG для распределения по ним реплик приложений.

### Составные части проекта, которые необходимо поднять:
 - __embedder__ - контейнер с моделью USE для генерации эмбедингов запросов
 - __redis__ - используется для обмена информацией между сервисами и кэширования ответов.
 - __ann__ - приложение, разворачиваемое для каждого индекса на отдельных нодах.
 - __gateway__ - служит в роли основного api-gateway проекта.

#### ANN

Служба принимает запросы на поиск ближайших соседей по заданному эмбедингу.

Всегда запускается в двух репликах на разных нодах с соответствующим TAG ноды, что повышает как пропускную способность, так и устойчивость системы.

При запуске считывает файлы с индексами и мапингами из локальнах папок в соответствии с заданным переменной окружения поколением данных.

При старте реплики после загрузки индекса и мапинга:

        Подключиться к Redis
        центр_кластера = получить центр из локального файла 
        список_кластеров = прочитать список кластеров в Redis

        IF кластер ноды не в список_кластеров:
            # регистрируем сервис
            пуш номера кластера в список кластеров в Redis
            создать хэш <cluster_num>_actual key=center value=центр_кластера
            создать хэш <cluster_num>_actual key=dg value=номер_поколения
        
        ELIF кластер ноды в списке И номер_поколения НЕ равно <cluster_num>_actual.get(dg):
            # готовим данные для замены
            создать хэш <cluster_num>_booting key=center value=центр_кластера
            создать хэш <cluster_num>_booting key=dg value=номер_поколения
            время жизни хэш = 3600
        
При выключении реплики:

        # проверяем первая ли реплика отключается
        IF в Redis нет хэша с флагом об отключении одной ноды: 
            создать хэш <cluster_num>_флаг, key=1_replica_isdown value=True
            время жизни хэша = 25s
        
        # есть ли данные для замены?
        ELIF существует хэш <cluster_num>_booting:
            new_data = {}
            <cluster_num>_booting.items() -> new_data
            
            del <cluster_num>_booting
            del <cluster_num>_actual
            
            new_data -> <cluster_num>_actual

        ELSE:
            # штатно выключаем
            удалить кластер ноды из список_кластеров
            удалить <cluster_num>_actual

Данные два блока нужны для реализации идемпотентности данных в регистре при загрузке нескольких реплик, для плавного обновления по схеме Rolling, а так же правильного перехода на прошлую версию при сбое.

Процедура поднятия реплик / обновления
1. при обычном включении - первая реплика регистрирует данные индекса в регистр, втора поднимается без изменений.
2. при штатном выключении - первая реплика, не увидив новых подготовленных данных, поднимает флаг о своей остановке и выключается, вторая реплика, увидив флаг об остановке первой реплики, удаляет данные индекса из регистра и отключается
3. при обновлении - первая реплика поднимает флаг и отключается. Начинает запуск с новой DG, реплика видит, что запись о кластере в регистре существует, но версия DG другая, создает данные на подмену. Балансер по healthcheck видит, что реплика поднялась, начинает отключать вторую реплику и переключать трафик на первую. Вторая реплика видит флаг, понимает, что она последняя, действующая на старой версии данных, заменяет данные в регистре на новые и отключается. Поднимается уже в новой версии.

Такая реализация может быть использована, если  ресурсы ограничены и в резерве нет машин, на которых можно спокойно поднять вторую версию реплик. Если машины есть, то, используя этот же код, но изменив порядок обновления на start-first и parallelism=2, можно реализовать blue/green схему.

В этом случае сначала поднимутся новые реплики, подготовят данные на замену, старые реплики, отключаясь, произведут замену в регистре.


#### Embedder

Служба реализована на основе готового образа tensorflow/serving:latest с монтирование к нему папки с обученной моделью и передачей имени модели в переменную окружения

#### Redis

Это основной канал обмена сообщениями между сервисами (регистр). Содержит информацию о номерах кластеров, развернутых на нодах и доступных для ответа, о центрах этих кластеров и о поколении данных. Позволяет нескольким репликам API-Gateway одновременно получать актуальные данные по доступным кластерам.

Так же используется для кэширования запросов и ответов модели для снижения нагрузки на сервисы.

#### Gateway

Содержит ручку для обработки запроса на получение ближайших соседей вопроса, а так же ручку для самоконтроля состояния сервиса.

Для минимизации нагрузки на сервер использует redis для хранения кэшированных данных.
Может запускаться несколькими репликами, все реплики актуальные данные по индексам получат из redis.

Алгоритм обработки запроса:  

        Проверить наличие вопроса в кэше 

        ЕСЛИ найдено:
            вернуть содержимое кэша
        
        ИНАЧЕ:
            получить эмбединг вопроса из Embedder 
            получить все доступные центры кластеров из Redis
            найти ближайший центр к эмбедингу вопроса

            ЕСЛИ близкий центр не найден:
                вернуть пустой список

            ответ = запросить k ближайших соседей у модели с этим кластером
            внести ответ в кэш
            вернуть ответ

### Playbooks

__ann-index-transfer__ - доставка индексов и маперов с центрами в заданные ноды (переменные vars: indx_mappers_cluster_<num>.yml)

__ann-service-start__ - запуск сервиса ANN на ноде (переменные vars: ann_cluster_<num>.yml)

__embedder-model-transfer__ - доставка модели USE на заданную ноду (переменные vars: embedder_vars.yml)

__embedder-service-start__ - запуск модели USE на заданной ноде (переменные vars: embedder_vars.yml)

__gateway-service-start__ - запуск сервиса api-gateway (переменные vars: api-gateway_vars.yml)

__redis-service-start__ - запуск redis
